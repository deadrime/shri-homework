## Install
```
yarn install
```

### Development
```
yarn run dev
```

### Build
```
yarn run build
```

### Lint
```
yarn run lint
```

## Почему vue ?
Потому что в нем классный шаблонизатор и удобные однофайловые компоненты, все очень быстро разворачивается и настраивается. К тому же в дальшейшем я хотел бы сделать именно на vue полноценное SPA для Яндекс Дома.

# Адаптивная вёрстка
Посмотреть:  https://shri-homework.now.sh/#/events

grid раскладку можно найти в components/Events

Используется 3 различных раскладки: 
+ < 750 для мобильных одна колонка, все блоки одного размера
+ \>= 750px - две колонки, большие и средние блоки занимаю всю ширину, маленький - 1 колонку
+ \>= 1200px - 6 колонок, большой занимает всю ширину, средний 3 колонки, маленький - 2

Изначально попробовал сделать через `grid-template-areas`, однако это не гибкий способ, так как при большем количесве событий все сломается. Скорее всего тут будет инфинити скролл с подгрузкой новых событий, так что решил делать через `grid-template-columns`. Единственный нюанс - для управление положением большего блока `.event--large` (Расположен слева или справа) нужны небольшие пляски с бубном (Попробовал сделать через js [тут](https://codepen.io/deadrime/pen/Xxmozp).)
Не стал включать это, так как не уверен, что такое чередование - часть задумки.

Из непонятностей:
+ Не нашел вариативного Arial, да и вообще с кириллическими вариативными шрифтами беда, отложил на потом.
+ Исходный формат данных в `events.json` не содержит в себе различных размеров изображений, не понятно, как их делать, не меняя формата...

# Работа с сенсорным пользовательским вводом

Посмотреть: https://shri-homework.now.sh/#/camera
Код лежит тут: `./src/components/Camera`

Решил смотреть на два ветора длинной > 10px и определять жест по тому, насколько вектора близки к тому, чтобы быть коллиниарными. Площадь фигуры образованной двумя векторами может быть большой (пральцы двигаются в разные стороны) или маленькой (пальцы двигаются в одну сторону - к центру или из центра). Сравниваю a.x/b.x и a.y/b.y и если полученное значение достаточно мало - значит вероятнее всего это зум, иначе - ротейт. 
Предполагаю, что можно было придумать что-то с матрицей поворота, но что-то я подзабыл линейную алгебру, чтобы соорудить вменяемую формулу.


# Мультимедиа

Код лежет тут: `./src/components/Live.vue`

Анимацию делал через scale и transform.
Детектор движения - делает снепшоты каждые 100мс и находит diff текущего и предыдущего, если он больше заданного значения - значит движение было. Добавил делей в полсекунды, чтобы было более наглядно.
Для громкости подключил анализатор, который просто находит в `inputBuffer.getChannelData(0)` максимальное значение.
Фильтры сделал при помощи CSS filters.
Хотел сделать, чтобы по-умолчанию грузило в 360, а когда разворачиваешь - грузилось 720, но оно почему-то начинает ругаться на CORS и перестает грузиться =(

# Store API

## Опции конструктора Store
 - state (`Object`) - корневой объект состояния
 - mutations(`{[type: string]: Function}`) - доступные мутации, для изменения состояния достаточно изменить переданный `state`
 
 ## Методы
 - run (`type: String, args?: any`, ) - вызвать мутацию
 - subscribe (`subscribe (handler: Function): Function(сurrentState, prevState)`) - подписка на изменения, `handler` будет вызван при любом вызове мутации и получит текущие и предыдущее состояние
 - unsubscribe (`unsubscribe (handler: Function): Function`) - отписаться от изменений
 - getState(`Function`) - получить текущее состояние
